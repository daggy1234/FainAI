{"data": [{"data": ["You know, it's not.", "For. I just went straight to college.", "Coming out of this. This is the first.", "Know. Yes.", "Yes. Things like."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=0&isPrimary=false&absoluteTime=13350507901.002", "start_time": 1, "end_time": 87}, {"data": ["All right, well. Everyone. Welcome to the days of class and design and the analysis of algorithms.", "Lecture number four. We'll be talking about divide and conquer today.", "Where we've been, we've been talking about iterative algorithms, recursive algorithms, correctness,", "efficiency, asymptotically, and induction, including just inductive reasoning in design and analysis.", "Today we'll start moving on, potentially do some new algorithm design ideas,", "and we'll start our first with a recursive algorithm design paradigm, the divide and conquer paradigm.", "We'll look at that through two primary canonical examples today, by the way,", "that is what we will often do in this class is introduce a general purpose algorithm design principle,", "and then look at a few canonical examples that demonstrate some of the salient aspects of it.", "So today we'll look at the two most common efficient sorting algorithms merge sort and the quicksort outputs.", "In today's installment of guest that algorithm. Anybody have a guess as to what this algorithm in the animation is?", "I've heard I heard Merge and I've heard insertions or any other guesses and I've heard QuickSort as well.", "Let's vote. This will be fine. If you think it's an assertion, sort raise your hand.", "You think it's merge sort raise your hand. Do you think it's quicksort raise your hand.", "It is quicksort. Yeah, that's right.", "That's right. I'm afraid I have no prize for you except for the slight joy at recognizing an algorithm.", "We're going to talk more about sort of quicksort today. And before I do that, some quick announcements.", "104: Divide and Conquer l:", "Mergesort, Quicksort, and", "Randomization", "Reference: Chapter 1 Algorithms", "by Jeff Erickson"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=1&isPrimary=false&absoluteTime=13350508080.502", "start_time": 180, "end_time": 291}, {"data": ["So you could turn in every single homework a little bit late over the weekend and still get an A in the class.", "No problem. Okay. But there is an incentive to try to get it done and turn it in on Thursday and enjoy your weekend.", "And I hope you will mostly be able to do that. This policy is intended to be humane and to provide for a small amount of flexibility if you need it,", "because I know your lives are very busy and packed.", "However,", "it is also intended to incentivize trying to finish your homework promptly and being able to move on to look at the next set of topics and problems.", "I will not provide extensions be on this or release from the extremely minor penalty or anything like that.", "This is a policy that rather than demanding that you ask for an extension or", "justify yourself to me provides flexibility to all of you without needing to ask.", "That is my purpose and my intention.", "Homework to on divide and conquer will be available later this week, probably by Thursday and do next Thursday as part of our regular tense.", "There will again be two or three theory problems and an applied problem on that homework set.", "Are there any questions about force announcements? Also, let us talk then about divide and conquer.", "I.", "2.", "3.", "Announcements", "Solutions to recitation exercises available on", "Canvas", "Homework I due this Thursday 1/25", "\u2022 Accepted late for up to 72 hours at very minor penalty,", "see the_pgJicy. No extensions beyond this.", "Homework 2 (divide and conquer) available later", "this week, due next Thursday 2/1"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=2&isPrimary=false&absoluteTime=13350508260.502", "start_time": 360, "end_time": 444}, {"data": ["Let's start with what we've already seen in a recursive algorithm.", "This is the recursive algorithm for calculating the maximum value in an array that we looked at last time.", "Let me just trace through the execution of this algorithm as we saw last time, we have a base case on line two and three.", "If we're only looking at one element, then just return that. That is the maximum.", "Otherwise calculate the maximum of the first and minus one elements online for recursively,", "and then check on lines five through seven whether the last element is greater than that.", "That was our algorithm. And in terms of execution, it looks something like this.", "We're going to calculate the maximum of this array with four elements.", "We're not in a base case. We make a recursive call. Hey, what's the maximum?", "The first three elements. Still not in the base case. Hey, what's the maximum in the first two elements?", "Still not in the base case. Hey, what's the maximum of the first one element?", "Now we're in a base case. We just check the very first element that's two, and we return it.", "Then we say, okay, we're looking at two. That was the maximum of the first element.", "2:", "3:", "4:", "5\u2022.", "6:", "8:", "Recursive Maximum Calculation", "procedure RMAX(A, n)", "if then", "return A[O]", "if \u2014 l] > m then", "return A[n \u2014 1]", "else", "return m"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=474&isPrimary=true&absoluteTime=13350508374.502", "start_time": 474, "end_time": 540}, {"data": ["we will generally make multiple recursive calls, not just one.", "The thing that makes it a divide and conquer algorithm, as opposed to just any other recursive algorithm that makes multiple recursive call", "is that those multiple recursive calls will be on non overlapping sub problems.", "If we make two recursive calls, the two sub problems, the first problem will be on a totally disjoint set of the input.", "Then the second one they'll have nothing to do with each other.", "So that's what we'll be looking at with divide and conquer. Today we'll look at a different paradigm of recursive algorithm design where your sub", "problems are overlapping in a couple of weeks when we talk about dynamic programing.", "But why think about divide and conquer algorithms? There are a couple of reasons.", "One is that as we look at next week, this paradigm of solving the problem by solving multiple independent sub problems turns out", "to be the most elegant way of achieving high degrees of parallel ization in algorithms.", "And by the way, that's all the buzzword today.", "I don't know if you all are into computer architecture, but the speed of individual computer cores isn't really increasing anymore.", "Yeah, Moore's Law that the speed of an individual core is going to like double or something every once in a while.", "That really hasn't been true at the same rate for many years now.", "Computers over the last decade or two have primarily physical computers have primarily been getting faster by adding more cores,", "but you can only exploit more cores if you can parallelize your algorithm.", "What's the easiest kind of algorithm to parallelize, divide and conquer?", "So that's one reason we'll talk more about that next week.", "A second reason, though, is that even when we're looking at serial execution or just traditional non parallel,", "the way we normally think about an algorithm executing on a single core,", "even if we're thinking about that, there are several instances where we will be able to come up with a more efficient algorithm,", "a meaningfully more efficient algorithm using divide and conquer techniques.", "Divide and Conquer: Recursive", "Algorithm that makes multiple", "non-overlapping recursive calls.", "Great for parallel algorithms (later), and", "sometimes more efficient non-parallel", "algorithms (this week)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=585&isPrimary=true&absoluteTime=13350508485.502", "start_time": 585, "end_time": 720}, {"data": ["Even looking at a recursive algorithm to calculate the maximum value in an array.", "Let me show you a different way to do that.", "I'm using a boring example to show you a variety of ways to solve the same problem with different algorithm design techniques.", "We looked at how to calculate the maximum value with an iterative approach.", "Look over and accumulate. We looked at it with a recursive approach just before.", "Here's a divide and conquer algorithm to calculate the maximum value of an array.", "Roughly speaking, the base case. We're going to run a Denver case, by the way.", "So problems by extra parameters. This is stereotypically how I'm going to do this.", "You'll notice that in the textbook, Erickson tends to denote some problems by instead passing a sub list that's sometimes more convenient to write,", "but it's sometimes annoying to implement in many programing languages.", "You'll see that I stereotypically will designate my recursive sub problems with extra parameters to the recursive calls.", "That tends to work in a language agnostic way in all possible programing languages, which is why it's the way that I remember.", "Okay, so I'm deprecating a sub problem. Compute the maximum value in an array between the indices L and R inclusive.", "That's how I'm designating a sub.", "Problem is by those those parameters, I'm using L and R to represent the left and right bounds of a range from which I want to find the maximum value.", "My base case then is if L equals R, or you could say is L greater equal to R?", "If you're worried about somebody messing it up and making this call with the indices swapped around,", "Divide and Conquer Maximum", "Multiple recursive calls on non-", "overlapping subproblems", "1: procedure DCMAx(A, l, r)", "2:", "3:", "4:", "5:", "6:", "7:", "8:", "9:", "10:", "if I = r then", "return A(r]", "else", "a = DCMAx(A, l, m)", "b = DCMAx(A, 1, r)", "if a > b then", "return a", "return b"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=801&isPrimary=true&absoluteTime=13350508701.502", "start_time": 801, "end_time": 900}, {"data": ["Three element. That one was three. That is return. The larger of three and five is five.", "So we return that and now we do our final merge step.", "The larger of four and five is five. So this solves the same problem that we've seen before in different methods.", "The diff, it's still recursive. The difference here is just that if you look at the recursion tree, it is not linear anymore.", "Right. It's a proper tree with some branching in it now.", "And indeed that will be true in general of the divide and conquer algorithms that will characterize in", "the divide and conquer algorithms is that they will be characterized by a recursion tree like this.", "In general, are there questions about this maximum example before we look at sorting?", "Divide and Conquer Maximum", "Multiple recursive calls on non-", "overlapping subproblems", "1: procedure DCMAx(A, l, r)", "2:", "3:", "5:", "6:", "8:", "9:", "10:", "if I = r then", "return A [r]", "else", "a = DCMAx(A, l, m)", "b = DCMAx(A, 1, r)", "if a > b then", "return a", "return b", "4", "2", "5", "4"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=6&isPrimary=false&absoluteTime=13350508980.502", "start_time": 1080, "end_time": 1131}, {"data": ["by repeatedly applying the recurrence and unraveling it until you reach the base case.", "What would that look like here? Key event is at most two times T over two plus C.", "\u2014 = (u) J 8U!AlOS"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=1248&isPrimary=true&absoluteTime=13350509148.502", "start_time": 1248, "end_time": 1260}, {"data": ["That's just the statement of the recurrence. I will substitute the recurrence again for the term t of in over two.", "How do I do that? By multiply by the two on the outside.", "I divide the inside by two and I have c.", "Here we go. I don't know why this. Every one of you is a powerful wizard.", "Why? It just like. Hi, it's my C, There is a C and we still have from before.", "Solving T(n) = 2T -", "T(n) 2T(n/2) + c"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=1260&isPrimary=true&absoluteTime=13350509160.502", "start_time": 1260, "end_time": 1296}, {"data": ["I've got that minus one. That's what I'm observing here.", "You can also go remember by forward substitution, if that's more intuitive to you starting at t of one,", "then calculating tier two and tier three until you spot a pattern.", "We will look, by the way, at other ways to solve this. Before that, other work is closing time work.", "Yeah. This is the relation with the sea. In the sea.", "Right. The non recursive term. So yes.", "Is at the end. The original interior is the same as at the bottom.", "Is the same as the old man in the bottom. Can you elaborate a little more?", "Yeah. So you say it's all been for you and not the same, and that's at all?", "Yep. So I'm just solving if you have this recurrence,", "I'm saying that at most end times tier one plus and minus one C and it's still the same variable it was before.", "Yes. So we'll look at a few more examples of these in the context of other recursive algorithms today.", "And later. Substitution is one method. It's not the only method you can use to get the answer.", "Solving T(n) = 2T -", "T(n) 2T(n/2) + c", "\u20144T(E + 3C", "= 8T \u2014)+7c", "is O(n).", "No speedup", "compared to rMax", "or iterative max.", "When will divide", "and conquer be", "faster?"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=8&isPrimary=false&absoluteTime=13350509340.502", "start_time": 1440, "end_time": 1515}, {"data": ["Just coming from all of the insert procedures on smaller and smaller sub ranges of the original array, That's where that complexity is coming from.", "And the same analysis you would get from an iterative insertion sort, by the way, you'd get the same summation.", "The solution to this is quadratic.", "This is an aromatic series, two kinds of series pop up again and again when one analyzes algorithms, and I hope that you've seen some of them before,", "I certainly hope if you took to a one with me that you've seen this arithmetic series before and the", "arithmetic series formula or a bit of reasoning on the side will tell you that this is quadratic.", "It's approximately n squared over two.", "I always like to remember that by remembering that, okay, the average value in that summation is in over two and I'm adding in terms.", "So the total is going to be roughly in squared over two. That helps me to remember it.", "I don't know if that helps you. This is the sum of an arithmetic series. So we were able to get a quadratic time.", "Solving T (n) = T (n \u2014 1) +n", "TOI) +n", "T(I) +2+3 + + (n\u2014 1) +n"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=9&isPrimary=false&absoluteTime=13350509520.502", "start_time": 1620, "end_time": 1686}, {"data": ["a sorting algorithm, this is what I am going to write nine times out of ten.", "I don't know what'll happen the other time out of ten, probably I'll lose.", "Mercer is a beautifully elegant algorithm to describe in plain English, and let me use that approach to you first.", "If you have anything to and I hope you will see what is elegant about thinking about sorting recursively here,", "both from our sort and for merge sort here you can sort iteratively.", "Most of them are quadratic time. I try describing one of them in really elegant English.", "Just try. Okay. Merge sort. It just is easy to say what we're going to do.", "If you have anything to sort divide what you have to sort into two halves.", "So we've divided the input now into two halves recursively.", "Sort the left half. Okay.", "We recursively sorted the left half of recursively sort the right hand grip did that too.", "Now, what do we do? Put them together.", "Merge the two sorted halves into one sorted array and we're done.", "That's how we saw with merge sort. Now I know what is in some of your minds right now because I have psychic powers.", "But how do you recursively sort. There are a couple of answers to this.", "One that is commonly used is trust the recursion fairy. I don't trust any fairies.", "I've never met the fairy, and I try not to trust strangers. What do I mean when I say trust the recursion fairy?", "I mean abstraction. How do we recursively sort?", "You just wrote the procedure to recursively sort.", "It's the same one. Apply on a sub problem.", "You might think the way to understand merge sort is to say, No, no, no, I need to go deeper than this.", "But what I just drawn to you is the way to conceptualize the design process of merge sort.", "If you understand this, you could write the algorithm recursively.", "Right. This is the big picture. Now, you might also be thinking how do we merge?", "Merging the two sorted halves is not a recursive sub problem of the same form.", "For that we do indeed need another algorithm, a helper procedure in this case.", "Indeed, you can think of merge sort. We talk a lot about reductions in algorithm reducing one problem to another, hopefully simpler problem.", "Mergesort"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=10&isPrimary=false&absoluteTime=13350509700.502", "start_time": 1800, "end_time": 1980}, {"data": ["First, just intuitively, given two sorted arrays, I want to merge them into one array with all the values from both in sorted order.", "To do this, I'm going to take two indices or pointers if you prefer.", "Think of it that way. Really, they'll just be indices starting at the beginning of the two sorted arrays.", "When I'm reasoning inductively,", "I'm taking advantage of the fact that the overall next smallest element between these two arrays must be one of these two values.", "For example, the overall minimum has to either be the minimum of the first array or the minimum of the second array.", "So it has to be one of these two first values.", "So I'll just take the smaller and insert it and increment the index for the array from which I just made the copy.", "So I increment that now. I've already copied that over again.", "I'm reasoning inductively. The next smallest element must be one of the two elements that my indices are tracking right now.", "Two is smaller, so I copy that over and increment the index and I simply continue in this fashion check.", "Which of these two values is smaller? Copy that one over increment its index and so on and so forth.", "Let me make that a little bit more formal to you and also put it into the context of an in place sort, which is what we'll look at.", "So I give you an array and I want you to sort the array I gave you as input, not create a separate copy of the array.", "How do we do that? Well, typically, actually, what that means, think about the merge sort.", "I would say sort the left half of the array, let's say from l2 M sort the right half of the array,", "say from M plus one to CR, using Allen R as my bounds of a range and using M as the midpoint.", "Okay. How do I merge those two halves? Here's what my picture looks like in memory.", "I have my array. It's sorted on the left half. It's sorted on the right half.", "I want to merge it together. I actually use a little bit of auxiliary memory in the merge sort procedure.", "So what I'm first going to do is say, okay, let me make another array with enough room to hold all the values that I'm merging.", "Then as before, I have my two indices starting at the start of the two sorted halves of my array.", "Okay. And I'm going to continue four and iterations.", "Where is the number of elements to be copied here? Of doing exactly what I said before.", "Merge Procedure", "Given two sorted arrays, want to merge them into", "one with all values from both."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=1995&isPrimary=true&absoluteTime=13350509895.502", "start_time": 1995, "end_time": 2160}, {"data": ["Don't attempt to copy this down unless you're bored, and that brings you joy.", "I went through it in this process because I think often people get very tripped up missing the forest for the trees.", "When you look first at the pseudocode and assume that what is very deep and important about this algorithm", "is how many indices I had to use to keep track of everything as opposed to the idea of the algorithm.", "That's why I focused on the idea of the algorithm first. And here I am simply showing you for reference.", "Notice this is a reference slide. If you want to go back and see one convention for keeping track of all the indices.", "Here is one. You can see a different one, by the way, in Ericsson's book.", "If you'd like to look at that,", "I think most things like keeping track of four or five different indices in an array over iterations is best digested on your own time.", "Okay. And so I won't use a lot of lecture time to do this. I will, however, give you a tip.", "And my tip is when you're thinking about digesting an algorithm, after you've looked at an example, after you've got the high level idea.", "After you understand the logic of the procedures, what do you do to really understand it?", "I think there are two things you should do. One is to prove that's correct.", "That requires you, if you're going to be formal,", "to pay very careful attention to all the details of an algorithm and really understand why it does exactly what it does in every case.", "Reference Slide: Index Detailed", "Pseudocode for Mergesort", "procedure", "if I < r then", "m = + r)/2J", "MERGESORT(A. t, tri)", "MERGESORT(A. m -V L, r)", "Can digest Indexing at", "convenience", "Fain Tim ro REALLY understand", "Provecorrectness\u201eend", "2. Implement it yourself", "Otherwise we're just nodding along", "i: procedure", "5:", "6:", "g:", "8:", "i 37", "B new, array", "for k I do", "else if j > r then", "else if .4iiJ then", "131k) \u2014Aljl;", "for k n \u2014 1 do", ".41/ B[kl"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=2247&isPrimary=true&absoluteTime=13350510147.502", "start_time": 2247, "end_time": 2340}, {"data": ["The algorithm is not so interesting,", "and indeed that will often be true of some of the recursive algorithms with divide and conquer and dynamic programing that we will look at,", "that the correctness will almost follow structurally from our understanding of the recursive structure of some", "problems and will in some ways not be so interesting and be almost like a factory made proof by induction.", "Later on we will look at greedy algorithm design, approximation algorithm design, where it will be much less obvious that an algorithm is correct.", "Okay. And we'll be glad that we looked at some of these examples of proof of correctness earlier.", "How would you structure this not so interesting argument? Remember, whenever you need to argue correctness and you've got to procedures,", "you first want to argue or analyze the runtime of the helper procedure because it doesn't depend on merge sort.", "Merge does not depend on merge sort. Merge sort depends on merge.", "So you would start by arguing the correctness of merge merge as an iterative algorithm.", "You could argue its correctness by induction over the iterations.", "That's the common structure of an argument for an iterative algorithm.", "I'm not going to repeat that. Here you can see a complete example in Erickson's text, if you would like.", "It is not very deep, but there are four cases that you have to do each one of them.", "None of them are supremely interesting.", "The second thing you would do is argue the correctness of the merge sort algorithm, given the correctness of the merge algorithm.", "This is a recursive algorithm. Typically, you would argue correctness by induction over the sub province, over the sizes of some problems merge sort.", "If you look just at that procedure right there, it's so simple that this is not much of an argument.", "Essentially is that in the base case, when you're looking at only one element, there's nothing to do.", "It's already sorted.", "If you suppose that it's correct for smaller sub problems and then you consider a slightly larger sub problem sorting a slightly larger range,", "then by the inductive hypothesis, the recursive call in line for correctly sorts the left half of the range,", "How to Argue Correctness for", "Mergesort", "1: procedure 10\u2022)", "2:. if I then", "MERGESOXI'(A, l,", "MERGESORT(A, + 1,", "MERGE(A, l, m, 77)", "The argument not especially", "interesting..."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=2376&isPrimary=true&absoluteTime=13350510276.502", "start_time": 2376, "end_time": 2520}, {"data": ["We will get a different recurrence than we've gotten before, but we can still analyze this by deriving recurrence relation.", "The base case is still constant time. Nothing to do, not even written explicitly.", "Otherwise, we make two recursive calls, each on an input of half the size, the left, half or the right half of the range.", "We then merge the two halves, which now you'll note has linear runtime complexity and the size of the range.", "Okay, we have to copy all of the elements over into B and then we have to copy all of them back onto em.", "So actually it scales as two times the number of elements, but linear asymptotically.", "So the following recurrence will characterize the asymptotic runtime given as two", "times to a minute or two for the recursive calls plus n for the merge procedure.", "You can write two in there if you wanted. That would be more precise but unnecessary to derive the asymptotic complexity.", "We could solve that by substitution, but we've already shown that a couple of times.", "Let's talk about different ways to solve this one way.", "As you might just know the answer to that recurrence. Okay.", "2:", "5:", "6:", "Runtime Analysis of Mergesort", "procedure l, r)", "if I < r then", "MERGESORT(\u00c4, I, vn)", "MERGE(A, l, m, r)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=2538&isPrimary=true&absoluteTime=13350510438.502", "start_time": 2538, "end_time": 2616}, {"data": ["One other view that you'll see if you read Ericsson's appendix two on solving recurrences is that you think explicitly about the recursion tree.", "So here this diagram from that chapter, if you'd like to review it later,", "considers the following abstract form of a recurrence for a divide and conquer algorithm.", "A recursive calls each on an input of size and over B with F of in additional work.", "So for example with merge sort, this was a equals to be equals to and this was just n right.", "Well, if that's the case, you can think about the recursion tree and we draw a node here for each recursive sub problem", "Another View: Sum Over All Calls", "in the Recursion Tree", "f(il/b)", "Jot.' b)", ",rrn/b\u2022\u00bb", "A recursion tree for the recurrence T(n) = a T(n/ b) /(rt)", "Erickson Appendix 2. Recurrences"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=2655&isPrimary=true&absoluteTime=13350510555.502", "start_time": 2655, "end_time": 2700}, {"data": ["Let me show you an example I wanted to solve here then.", "Is it most for T and then over to plus end the top level node has to do in work.", "Okay. That non recursive work that's linear.", "In this case I make four recursive calls each on an input of size in over two so I could do it over to work at each of those.", "Each of those makes for recursive calls, each on an input of half the size.", "We're in over four, so I do it over for work at each of those notes and so on and so forth ad nauseum,", "until I get to the base case, which let me assume is that size and equals one.", "And what is the total number? Let me some this over the levels of the recursion tree at the topmost level I just had n At the second level,", "I had four in over two four nodes each doing it over to work.", "At the third level. I had 16 nodes each doing an over four work and so on and so forth.", "Okay, now that we derive if I just add those together and plus four and over to 16 and over four, so on and so forth.", "Okay, How can I write that summation more abstractly?", "Well, I can factor the in out of the summation.", "Right. There's a factor in, in every term. So let me just factor that outside of the sun and then it's one plus two plus", "Example by Recursion Tree", "4T(n/2) + n"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=2781&isPrimary=true&absoluteTime=13350510681.502", "start_time": 2781, "end_time": 2880}, {"data": ["then the solution to recurrence is end to the C.", "This is the case where the runtime of your recursive algorithm is going to be dominated by the branching below up in your recursion tree.", "A lot of the work is going to happen at small sub problems very deep in the tree in this case.", "Right. This is basically saying that the the amount of work you are doing per per", "level is something that is small compared to how rapidly the tree is growing.", "The second case is a little weirder. Again, I reiterate the notes are all there.", "And this is also this theorem is included in Ericsson's book and Wikipedia.", "So don't feel like you necessarily need to copy every character down.", "If you're feeling rushed by them. The second case is where the non recursive work is very close to this factor into the see how close?", "Well, it's the factor into the C into the critical number you should think of into the sea as characterizing the growth of your recursion tree.", "Plus with logarithmic additional overhead log factors on top of it, it's very close to end of the sea.", "If that is true, then the right the solution to your recurrence is also very close to into the sea, but not exactly equal to one extra log factor.", "What's going on there? I will show you an example of flying bees in a moment.", "But this is the very close to case. The final case is complicated.", "But roughly speaking, this is the case where the non recursive part of the work dominates.", "Where the work you have to do at each level of the recursion tree is much larger than the growth of the recursion.", "Tree is our final case here. Most of the work will be done high in the recursion tree as opposed to in the first case.", "Most of the work will be done deep in the recursion tree. In this case, under a regularity condition that will probably not be important.", "In most examples you will look at. The answer is simply that it's dominated by f of in by that non recursive term.", "There is this caveat. It's not usually an important caveat, but it does exist.", "I do not expect you to memorize this theorem necessarily.", "Indeed, there's this lovely note from Erickson's text that this theorem allows us to bypass recursion,", "trees or substitution for many standard recurrences.", "But many people, including Jeff, those are his words I've inserted myself.", "Unifying Method for Common Recurrences", "(Also known as Master Theorem)", "Suppose you want to solve T(n) S aT(n/b) + f (n).", "Calculate c = logb a", "Cases:", "f (n) is O (nd) ford < c:", "T (n) is 9(nC)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=17&isPrimary=false&absoluteTime=13350510960.502", "start_time": 3060, "end_time": 3240}, {"data": ["Log base B of A is the log base two of two, which is one.", "Now we are in case two.", "We're in case two where the work we do at a given level in log n for a given sub problem in log n is very close to the growth rate of the recursion.", "Tree X in particular here C is one and F of n is of into the one times log in to the one for k greater than zero right K is one greater than zero.", "So the solution is again into the C or into the one times log in them to the k plus one k was one.", "So plus one is two. We would conclude that the solution is theta in log squared event for this recurrence.", "This would happen, for example, if you had a recurrence with the same kind of like recursive pattern as merge sort,", "but that instead of a merge procedure in linear time sorted and after each set of two recursive calls, you get this.", "Applying the Unifying Method", "T(n) = 2T(n/2) + n logn", "a = 2 b = 2 f (n) = n log(n)", "Calculate c = logb a = logz 2 = 1."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=19&isPrimary=false&absoluteTime=13350511320.502", "start_time": 3420, "end_time": 3492}, {"data": ["but also by the time we're sorting even just 32,000 integers is taking over a minute by the end of the speedup factor.", "The comparison between these two is growing. That's what it means for this to be an asymptotic improvement in the efficiency of the algorithm.", "By the time you get up to 32,000. The runtime gap between these two implementations is more than a factor 1000.", "So you should care and prefer an in log, an algorithm.", "If you can think of one over a quadratic time algorithm, it is not a small difference.", "O(n log(n)) sorting or O(n2)", "sorting, who cares?", "Comparing empirical runtimes on Professor Fain's", "puny laptop of mergesort and a quadratic iterative", "sort (in Python).", "n (elements to Mergesort", "Bubblesort", "Speedup factor", "sort) in", "thousands", "runtime in", "seconds", "0.002", "0.004", "0.008", "0.018", "0.038", "0.081", "(O (n2)) runtime", "in seconds", "0.104", "0.323", "1.271", "5.031", "20.597", "81.701", "81x"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=20&isPrimary=false&absoluteTime=13350511500.502", "start_time": 3600, "end_time": 3633}, {"data": ["I stopped the recursion and just random insertion sort. It's not asymptotically faster, but it was about 20% faster.", "And you'll commonly find that the details of exactly what that size should be and exactly what factors speed up you'll get are language dependent,", "machine dependent input, size dependent, everything dependent.", "So it has to be two, which is why I talked about this first.", "And in general algorithm design, we're going to talk about this first, not because this doesn't matter, but because this is a secondary optimization.", "The first thing you do is make sure you have an asymptotically efficient algorithm.", "Then if it is important or necessary for your application, you might wish to think about tuning constants.", "And this is a fairly common trick to tune constants for a divide and conquer algorithm.", "That's enough of me talking. I'd like you to talk to your neighbors and answer a few questions of your own.", "Constants and Practical Base Case", "Size for Mergesort", "TIME TO SORT 1 MILLION ELEMENTS", "speedup from", "tuning base case size", "16", "32", "64 128", "256", "512", "base_size (run insertion sort at this scale)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=21&isPrimary=false&absoluteTime=13350511680.502", "start_time": 3780, "end_time": 3840}, {"data": ["That's what it's like to be one of those.", "It is the only group.", "I know you have every.", "Well, I. If we're not going to be able that.", "In-Class Exercise", "duke.is/8/t53k", "Talk with your neighbors,", "Submit on your own.", "Graded for completion,", "not correctness."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=22&isPrimary=false&absoluteTime=13350511860.502", "start_time": 3960, "end_time": 4065}, {"data": ["Give us your best. We just got one more time. I'm sorry.", "Oh, we're fine. Yeah, Come on.", "I got to get out of here.", "Now let's come back together.", "I need to have your attention, please.", "Your history. Yes.", "Thank you. Thank you. Yes.", "I still think I have your attention, please.", "I do love it when the question generates a vigorous debate.", "Well, conversation is all right.", "So in the first question, we've got a linear, iterative algorithm,", "and we're debating whether algorithm B, which is divide and conquer with two recursive calls.", "So probably size in over to constant merge case. Which one is better?", "Most of you think that these two are asymptotically equally efficient, and that is correct.", "In this case, both algorithms have linear complexity.", "This is the recurrence we saw, if you recall, for the divide and conquer maximum algorithms.", "And the solution to it was linear. Second question.", "We've got a quadratic time, iterative algorithm where you've got to divide and conquer algorithm.", "Two recursive calls are problems of size in over two, but the merge step is now of in log in where the non recursive work is in log in.", "Now which one is better? Both of you believed algorithm B is asymptotically more efficient, which is correct.", "Okay. This recurrence is the one that we just looked at.", "T event equals to t event over two plus n log in. The solution is an log squared event.", "So it just adds an extra log factor which is still much faster than quadratic or in squared.", "(1/23/2024)", "104 In-Class Exercise (1/23/2024)", "CS 330 2024 On", "1. Suppose you an O(n) iterative algorithm", "For the problem. pu able to design a divide and algorithm On an", "input Of Size n It makes 2 recursive on Subproblems Of Size The merge", "Step and base case are", "WIIi-th is true? \u2022"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=23&isPrimary=false&absoluteTime=13350512040.502", "start_time": 4140, "end_time": 4320}, {"data": ["We're going to look also divide and conquer, but with a radically different parity.", "Mercer. Hold on, hold on, hold on, hold on, hold on, hold on, hold on, hold on.", "Stop. What are you doing this all semester?", "Every class I've ever taught. If someone smells that we're about done, all of you instantly start leaving.", "And we lose the last two or 3 minutes of class time. And I recognize that you individually do not mean to be rude,", "but 250 of us doing it together means that we can't actually use the last couple of minutes of class time.", "So thank you very much for your patience today.", "We looked at merge merge sort very lazily divides a problem into two sub problems just the first half and the second half of the array.", "We have to do a lot of work in the merge step.", "Combining the answers from those two recursive calls. QuickSort will also efficiently sort an array but with the opposite idea very carefully dividing", "into two sub problems and then with a fairly trivial combined step at the end of do nothing.", "It will also be different in that its analysis will be randomized for a good implementation of QuickSort.", "We will have to introduce randomness into our algorithm and think about how to analyze the expected behavior of that algorithm.", "So we'll do that next time. Thank you very much for your patience and please enjoy your day.", "Take care all. Now.", "Quicksort and", "Randomized Analysis"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=49d307d3-1f74-41e2-99f4-b1000146e17c&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=4410&isPrimary=true&absoluteTime=13350512310.502", "start_time": 4410, "end_time": 4500}, {"data": ["Okay, so let's suppose you look at this and you say, Well, I want to be able to answer, but if you didn't that you want to go to square.", "Okay. Because that's a bound which o of in the case you will matter which is the situations.", "Okay so it's just that sometimes it might be that I can't think I don't appreciate.", "I should just like start with this is how my situation is not clear either.", "Right. Okay. Right. You shouldn't give an answer that's like this is the answer o, but only if the tree happens to have something else.", "Okay. And so then if you're saying it's valid right now.", "No, but I do have a smaller bound on it where it's omitted and I need to move to the next question.", "As we learned today or talked about today, where all has to go on the record, we everything get something out.", "There's like sometimes. Yeah, I guess she calls me you.", "I'm sorry. If you're like, you've got to do something.", "I think that it would be helpful in terms of the form we just looked at for divide and conquer.", "Okay. For precisely the reason that the only difference is. Yeah.", "So this is you just have to use the house, let's say, like there are a couple cases where you only have one or two, right?", "You do that. Why is it that long process of making that provision next year?", "And how many times do you know that and how long? How many has also happened to me, If I do a direction, I have undefined and so I don't see.", "Are you used? This is the thing.", "The reason about just the question. Yeah.", "And it is the numbers in the range. Yeah.", "So let's say it's way smaller than the number of."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=6141db72-da61-4b62-8ebc-b1000146c7b8&sessionPID=0ea04ff8-e25f-4bba-910c-b0ce014751bf&number=26&isPrimary=false&absoluteTime=13350512580.502", "start_time": 4680, "end_time": 1000000}]}
{"data": [{"data": ["I just got right across the street and.", "Yeah. This is all about.", "One. I mean, I used to have.", "Yeah. I work for the Navy.", "I'm like, Oh my God, oh my God.", "I feel like I'm not gonna make it.", "I was like, I'm not going to do it right now.", "I'm like. I.", "I haven't seen. I'm like, Oh, come on."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=0&isPrimary=false&absoluteTime=13351717501.039", "start_time": 1, "end_time": 180}, {"data": ["And you, I.", "I think that's interesting. All right.", "Hello and welcome, everyone.", "Welcome to lecture number eight in your favorite algorithms, class and mine come side 330 on the design and analysis of algorithms.", "Hey, we're going to talk about dynamic programing this week. It's not really about programing, it's really about algorithm design.", "It's kind of dynamic, kind of cool. I think you're going to like it.", "108: Dynamic Programming I", "Reference: Chapter 3, Algorithms", "by Erickson", "13", "21", "8", "5"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=195&isPrimary=true&absoluteTime=13351717695.539", "start_time": 195, "end_time": 246}, {"data": ["we're going to first introduce dynamic programing as a concept and a technique using as a small example, computing the Fibonacci numbers.", "And then we'll talk about a more interesting problem.", "We'll talk about a class of problems that are often tackled with dynamic programing called sequence alignment problems.", "And we'll look at one example in that class, the longest common sub sequence problem that was on the agenda for today.", "Any questions about announcements for today's outline? All right.", "I.", "2.", "Outline", "Introduction to Dynamic Programming:", "Computing Fibonacci Numbers", "Sequence Alignment Problems: Longest Common", "Subsequence with Dynamic Programming"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=285&isPrimary=true&absoluteTime=13351717785.539", "start_time": 285, "end_time": 321}, {"data": ["And it'll kind of relate to thinking back about data structures.", "Maybe it's been a while since these thought that.", "So suppose that you want to write a parallel algorithm to get all of the numbers in an array that are less than or equal to X?", "Okay, You would say I've got a big array of numbers and I don't want the ones that are bigger than a thousand.", "I want only the numbers that are less than or equal to 1000.", "Here is my parallel algorithm To get all of those numbers, you say, Naturally enough,", "let me generate a list online too, and then let me do a parallel for loop.", "Check each of the values in the array in parallel. And if it's less than that x value, then I'll go ahead and append it to my list.", "Right. So you have some list that looks like this.", "It's got a bunch of stuff in it, and then there's some room at the end.", "You might implement this list in different ways, but this actually introduces a deterministic race.", "You actually have multiple threads that are trying to write whatever this end of the list position is.", "What exactly that deterministic race will look like depends on what kind of list you're using.", "Presumably you're using either a linked list, in which case to a page to a linked list.", "What are you actually storing? Think back to our data structures Date together.", "You're storing a pointer to the last node. Okay.", "And then when multiple threads are trying to append at the same time,", "multiple of those threads are trying to create a new node and then update the last pointer at the same time,", "while they're also potentially trying to read the last pointer to tell where the end of the list is, that will be the form of the deterministic race.", "You might say, Well, that's okay, I don't like these. I was using an array based list.", "Remember that an array based list would implement an append or adding something to the end of", "the list by storing the index of the next open position in the array at a given point in time.", "So in this kind of a model that we're looking at, you have multiple threads that are trying to both read the index of the last open", "position and potentially update it when they write an element all at the same time.", "So both whichever of these implementations you're using, this kind of a thing would actually result in indeterminacy rays.", "You would if you ran this, if you were to implement this in a language and actually run this code,", "what you'd find is that at the end only some of the values actually ended up in your final list and", "some of them got left out because they'd potentially been overwritten at previous stages here.", "So just a quick reminder, as we all think in parallel from recitation and homework and lecture last week, questions about this example.", "All right, good. Let's talk then about dynamic programing.", "2:", "3:", "4:", "6:", "Quick Note about Determinacy Races", "with Lists \u2014 Data Structures Review", "Remember when I said...", "Warning: Very easy to introduce a determnacy race 'n a", "parallel for loop by accident", "procedure PFILTER(A, :r)", "F = new List", "parallel for v in A do", "if u then", "F.append@)", "end parallel for", "return F"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=2&isPrimary=false&absoluteTime=13351717860.539", "start_time": 360, "end_time": 522}, {"data": ["which I find kind of psychedelic to look at. Maybe you do too. Otherwise you can just think of them as a sequence of numbers defined as follows.", "The first and second elements are one, and subsequent elements are simply the sum of the two previous elements in the sequence.", "So one plus one is two, one plus two, it's three, two plus three is five, and so on and so forth.", "This defines an infinite series of values.", "You could define the Fibonacci sequence using a recurrence relation.", "Indeed, arguably because the relation, the Fibonacci numbers are recursively defined, an element is equal to the sum of the two previous elements.", "The most natural way to write a definition of the Fibonacci numbers is with the recurrence relation.", "We have our base case that the incidence number is one for any equals one or two.", "Otherwise it's the sum of n minus the n minus one in the end, minus two elements.", "That's fascinating.", "Fibonacci Numbers", "1, 1, 2, 3, 5, 8, 13, 21, ..", "13", "21", "8", "5"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=3&isPrimary=false&absoluteTime=13351718040.539", "start_time": 540, "end_time": 609}, {"data": ["Suppose you do write that program. This is a working Python program to calculate Fibonacci numbers.", "It works. It calculates the numbers correctly. It's very straightforward.", "Suppose you run this, you might, if you were to run this on your own device, observe a curious trend.", "You think this is a simple algorithm. I'm just computing like the 30th Fibonacci number or something like that.", "What could go wrong?", "And you quickly discover that by the time you're trying to compute even just the 40th Fibonacci number, not a particularly large one,", "what computer scientists large to us means like maybe one or 2000 bits now like two to the 1000 or something.", "40 is tiny, a tiny constant.", "Nonetheless, even trying to compute something like the 40th or the 48 something like this Fibonacci number will fail horribly.", "Empirical Observations", "def fib(n):", "if n", "2:", "return 1", "else :", "return fib(n-l) + fib(n-2)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=672&isPrimary=true&absoluteTime=13351718172.539", "start_time": 672, "end_time": 720}, {"data": ["To think about why, let's consider the recursion tree of the algorithm we just looked at for calculating Fibonacci number at a high level.", "The observation I would like you to make as we transition from divide and conquer recursive algorithms to dynamic programing algorithms,", "is that we are no longer dealing with independent sub problems.", "We were in the world of divide and conquer. We were designing algorithms where we made a recursive call on one subset of the input and then maybe", "another recursive call on a totally disjoint set of the in the input a two totally independent problems,", "both of which were making rapid progress. S toward the base case. That was our canonical kind of setup.", "That's not happening here with the Fibonacci example.", "Our recursive algorithm, when first trying to compute the instead the notching number made two recursive calls,", "one where the input decreased by one another with the input decreased by two.", "That is to say the two sub problems we called on were in minus one instead of the minus two.", "Now each of those, if it is not in the base case, will also make two recursive calls,", "one where the input decreases by one and another where the input decreases by two.", "So seven and minus one will call two within minus two and in minus three.", "Then minus two will copy that, then minus three of the minus four.", "Now I have color coded these in a very particular way.", "You will note that the same sub problem, the same recursive call is appearing multiple times in the same recursion tree.", "We have not seen that happen yet, but it is very problematic in this case.", "Think about what that entails when we call filled in minus two, colored in purple on the right.", "On the second level, everything that happens after that has to be done in order to compute the the then minus two.", "Fibonacci Recursion Tree", "Can't Divide and Conquer:", "Overlapping Subproblems"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=786&isPrimary=true&absoluteTime=13351718286.539", "start_time": 786, "end_time": 900}, {"data": ["I get more than one recursive call and they're all making only arithmetic progress toward the base case.", "That's always going to give you some kind of exponential in the exact form of the exponential.", "They vary, but that's always a bad thing when you've got multiple recursive calls, each only making arithmetic progress toward the base case.", "The reason that this is so slow is not because an individual call is slow.", "It's because there are so many calls, exponentially many recursive calls.", "But there shouldn't need to be exponentially many calls. Okay.", "The problem is that we aren't actually remembering what we have already computed.", "We are re computing seven in minus two twice.", "We are re computing. Fill it in minus three, I think four times or something like that, and so on and so forth.", "Fibonacci Recursion Tree", "Can't Divide and Conquer:", "Overlapping Subproblems", "fib(n)", "fib(n-l)", "fibCn-2)", "fibCn-3)", "fib(n-3)", "2 2T(n\u2014 2) + c", "is 0(211/2).", "Branching factor greater than 1", "+ arithmetic progress toward base case", "exponential recursive calls.", "fib(n-2)", "fib(n-4)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=6&isPrimary=false&absoluteTime=13351718580.539", "start_time": 1080, "end_time": 1134}, {"data": ["We don't want to repeat work. Yes, the question for development 75 is in five.", "Yeah, that's just the name of my procedure. And it's just short for memorize Fibonacci.", "We're competing the Fibonacci numbers with notation. What difference does this make?", "Not a big difference in the way we wrote the algorithm. We introduced an auxiliary data structure.", "We only recursively computed something if we didn't already have it in the data structure and then added it in.", "That's all we did. But it makes the world of difference.", "2:", "3:", "4:", "5:", "6:", "Memoized Recursion: Don't", "Recompute Subproblems", "Use a data structure to store", "the answers to subproblems", "1: procedure MFIB(n, M)", "Only recurse if you don't", "have the answer yet", "M[n] = MFIB(n \u2014 1, M) + MFIB(n \u2014 2, M)", "And make sure to store the", "answer", "if n < 2 then", "return 1", "else", "if n M then", "return M [n]"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=7&isPrimary=false&absoluteTime=13351718760.539", "start_time": 1260, "end_time": 1299}, {"data": ["In this case, even linear makes a world of difference.", "Recursion Tree with Memoization", "MFIBCn)", "MFIB(n-1)", "MFIB(n-Z)", "MFIB(2)", "l: procedure M)", "2: if n S 2 t hen", "return I", "4; else", "if n M then", "= MFlB(n \u2014 I,M) + MFIB(n \u2014 2, M)", "return", "\u2022 Less than 2n recursive calls", "MCn-3J", "\u2022 Each call is 0(1)", "\u2022 Total runtime is O(n)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=8&isPrimary=false&absoluteTime=13351718940.539", "start_time": 1440, "end_time": 1446}, {"data": ["In case you don't believe me. Here's again working Python code that does precisely what we just described.", "To memorize the answers to the sub problems to compute these Fibonacci numbers.", "You will recall before that to calculate like the 40th Fibonacci number with the basic recursive algorithm took like 20 seconds.", "And to calculate the 48th I gave up after a minute or two and my computer hadn't finished.", "We are now with minimized recursion computing the 800th Fibonacci number in a negligible fraction of a second.", "That's the degree of difference that memorization can make.", "Or intelligent recursion remembering the answers to some problems and not repeating computation can make in practice or.", "Other questions about this technique of memorization and the idea of the problem with repeated costs calls to the same sub problems.", "Yes. How do you do it?", "How do I know there was less? So where did this analysis come from?", "So here, I'm tracing the recursion. And the question is, why is this linear?", "The basic more general argument, rather than tracing the recursion trees only tell you is again,", "that we're only going to compute a given recursive sub called once because after we've computed it,", "once we put it in the memo and then we immediately return whenever we call it again.", "So we're only going to solve each sub problem once there are a linear number of such problems as maybe the more general way to think about it.", "We're back to polynomial time here. Very good for us.", "I will note that Python doesn't like recursion beyond a certain limit.", "It gets annoyed with your stack frame, but that's a bug in python, not a bug with the algorithm.", "Memoized Recursion Empirical", "Observations", "def", "M = dict", "return mfibCn, M)", "def mfibCn, M):", "if n 2:", "return I", "else:", "if n not in M:", "N", "Time (s) to compute n'th", "Fibonacci number", "\u00f8.\u00f8\u00f8o", "Recursi\u00f6nError\u2022. ma*imum", "recursipn depth exceeded,", "M[n] = mfib(n-lj M) + mfib(n-2, M)", "return MCn]"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=1500&isPrimary=true&absoluteTime=13351719000.539", "start_time": 1500, "end_time": 1620}, {"data": ["The algorithm works just fine. However,", "it might motivate you to think about a different way to solve the same problem or to", "deal with the same kinds of issues in general with the technique of dynamic programing.", "Either you deal with this issue of repeated sub problems with memorization or by solving this sub problems.", "Bottom up is what people will often say in some iterative fashion and will", "focus much of the rest of our attention on that approach to thinking about it.", "We're still going to use an auxiliary data structure to store the answers to some problems.", "So the intuition is still similar. We don't want to repeat computation for sub problems.", "We're going to store the answers to some problems. Let's say an auxiliary data structure like an array.", "But rather than starting with the problem of interest and then working our way down to a base case as we do when recursion executes,", "we'll instead think about starting out a base case and iteratively computing the solution to larger and larger sub problems.", "We could do that to compute Fibonacci numbers by, for example, having an array of sufficient length to store all the answers to some problems.", "All the Fibonacci numbers up to the end, for example, and then initializing.", "This is being done on line three our base cases and observing the key property", "that we iterate over our sub problems are being stored in entries in this", "array that we iterate over our sub problems in such an order that we always know the answer to sub problems on which the current iteration depends.", "For example, for the Fibonacci numbers to calculate the ninth, you need to know the two previous.", "So we should iterate over these sub problems in such a way that we always know the two previous Fibonacci numbers.", "That's not a weird iteration order. That's probably the natural one for you, which is to iterate from smaller to larger Fibonacci numbers.", "There will be examples later on where the iteration order will not be so obvious.", "So I want to point out the idea first that we want to iterate in this case so that when we're trying to compute,", "let's say the third Fibonacci number, well, that depends on the two previous.", "We need to make sure that we had already computed those. Then we want to compute, let's say the fourth of the 90 number.", "That depends on the two. Yes. We need to make sure we had already computed those.", "If you think about this order of the dependencies computing these values from", "left to right or from smaller to larger sub problems will satisfy this property.", "You'll always know the things on which the current iteration depends.", "This algorithm clearly has linear runtime When you look at it written,", "there are linear number of iterations and each takes a constant amount of time to implement.", "1:", "2:", "5:", "Bottom-up Iteration", "procedure DPFIB(n)", "F new array of length n + I", "F[ll = F[2] = 1", "for i = 2 to n do", "F[i] F[i\u2014 1] + Fli-2]", "return F[n]"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=1620&isPrimary=true&absoluteTime=13351719120.539", "start_time": 1620, "end_time": 1800}, {"data": ["Sometimes writing an iterative algorithm. There are a couple of reasons you might do it.", "One is it might be more clear or clean. Some people might think that.", "Another is that it might be faster by constant factors.", "Another is it might get you around languages that don't like recursion as much.", "But another reason is that it may sometimes become evident to you when you write an iterative, bottom up, dynamic programing algorithm,", "how to optimize the memory that you're using that will often actually show up with memorize recursion is less obvious how you would do this.", "You end up having to use about a linear amount of memory to compute the infinite number.", "When we wrote that bottom up algorithm, you may have noticed and we go back to the dependency slide,", "you may have noticed that at a given point in time, computing the next iterate depends only on the two previous.", "It does not depend on all of the previous.", "And so it's actually not necessary to store all of the previous problems.", "It suffices at any given iteration to only have stored the two previous so we can optimize the amount of memory that", "we're using with this bottom up dynamic programing algorithm by simply storing the two previous Fibonacci numbers,", "iteratively computing the next,", "I'm computing the next with X on line five as the sum of the two previous and then updating so that now the first element", "of zero stores what was previously in position one and what's in position one is the next value we just computed.", "And you can simply continue doing this until you find the error rate of interest.", "That is to say we can solve the problem with the same runtime,", "but using only a constant amount of auxiliary memory instead of a linear amount of auxiliary memory.", "So we'll sometimes have an opportunity with bottom up dynamic programing to optimize our memory usage as well as our runtime,", "usually runtime first and then worry about memory,", "usually by looking at how you're solving the sub problems and asking, Could I get away with not saving all of them?", "Yes, a question about this. The space optimized one makes sense to me on a prior slide idea that I missed it.", "But why is the array Why is it to be sized? Plus one more starting clusters.", "The question is why is the array of size and minus in plus one?", "It doesn't need to be. I'm lazy and I don't want to have to adjust the indexing.", "So I'm just not using position zero because I'm defining the Fibonacci numbers as starting with the first element.", "It's just a zero indexing thing. Thank you. Other questions about this Fibonacci example.", "Yes, that's correct.", "Still linear runtime here, the same runtime, but now we're using much less memory if.", "Iterative DP Space Optimization", "I: procedure DPFIB2(n)", "2:", "3:", "4'.", "6:", "7:", "8:", "F new array of length 2", "F[01 F[l] = 1", "for i = 3 to n do", "F[0] = FIIJ", "return F [Il"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=1800&isPrimary=true&absoluteTime=13351719300.539", "start_time": 1800, "end_time": 1977}, {"data": ["And I'm taking this out of Erickson's book. This is a point about which I agree.", "You may have heard vaguely of the idea of dynamic programing, and it may have been explained to you as filling in tables.", "That is a crude and I would suggest not a very helpful way of understanding the technique of dynamic programing.", "The technique is really about understanding the recursive structure of algorithmic problems in terms of smaller sub problems,", "and then optimizing how you compute that recurrence either by memorization or by finding a valid", "iteration order to compute the answer to sub problems bottom up from the base case iteratively.", "That latter approach doing it bottom up from the base case iteratively requires you to store those sub problems somewhere.", "Often you store them in some kind of a table. The fact that there is a table is somewhat ancillary to the technique.", "Okay. It is really about thinking recursively to formulate a recurrence that characterizes what it is that you want to compute.", "For example, with the the Nazi numbers, if you've done that, you can write a recursive algorithm almost mechanically,", "but if it has overlapping some problems, it may be quite inefficient.", "You have two ways of dealing with that problem. One is to use minimization.", "Alternatively, and we will generally think in this direction to identify the order of sub problem dependencies and find", "a valid order in which to iterate over the sub problems from the base case to the case of interest.", "Okay, that's what dynamic programing really is.", "We've only looked at the a minimal example so far, maybe not the most interesting example,", "but I hope it clarifies the ideas better from a structural perspective.", "I now like to look at what I think is a more interesting example.", "This is generally the class of sequence alignment problems where you've got two different", "sequences of values and you want to find something about an optimal way of aligning them.", "Okay. We'll focus specifically on what's called the longest common sub sequence problem.", "Dynamic Programming in General", "Dynamic programming is not about filling in tables.", "Its about smart recursion!", "Chapter 3, Algorithms by Erickson"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=11&isPrimary=false&absoluteTime=13351719480.539", "start_time": 1980, "end_time": 2124}, {"data": ["Okay. Similarly to ATC is a sub sequence of the second string formed by deleting CMG and then taking what's left over.", "And in fact, the length of the longest sub sequence, the longest string I could say that is a sub sequence of both of these two strings is three.", "You won't be able unless I removed up to find a string of length greater than three.", "That is a sub sequence of both of these. The crucial property.", "When I say a sub sequences formed by taking what remains after deletions is that you can't change the order in which the characters appear.", "Right. That's the crucial limitation. You can't arbitrarily rearrange them.", "There are different variants on sequence alignment problems. So this is just one variant that we'll look at of particular interest.", "You can think of computing the length of the longest common subsequent between these two being like asking the question what do they have in common?", "Modulo errors, you could delete that modulo possible ways of aligning matched characters, for example,", "matching the first A and in the TS and in the CS, potentially deleting some things in between.", "Sequence alignment problems show up in many different contexts. For example, simple ways of trying to calculate optimal spelling discrepancies.", "You could use an approach like calculating the longest comments of sequence,", "the length of it to try to compare how similar two words are to one another, and whether one might be a typo of the other.", "Perhaps more interestingly, you could use this or similar ideas in sequence alignment,", "different variants of this to try to calculate the similarity of a genetic sequence.", "Thus, the letters that I have chosen and I give you two sequences of DNA and I ask you how similar are these two sequences?", "Are they similar or different?", "It turns out that's a very basic kind of question you might very often be interested in when comparing genetic sequences.", "But how do you do it right?", "One way is to say, I'm going to allow for deletions and then calculate the longest sequence of the DNA that is common between the two strands.", "That's precisely this problem. There are other variants on the sequence alignment problem, especially in the context of genetics.", "For those of you who are interested in computational biology, you can use it for trajectory analysis.", "Suppose I give you two GPS traces of two different individuals or two different vehicles or two different planes or something like this,", "and I ask you, are they similar or are they different?", "I give you many such trajectory traces and I ask you to identify the most similar traces or the ones that are very different from one another.", "How will you do this? A trajectory is a sequence of many points.", "You might want to think about distance under an optimal alignment of those points.", "Longest Common Subsequence", "\u2022 Longest Common Subsequence (LCS). Find the", "length of the longest string that is a subsequence of", "a and b.", "\u2022 Example. The longest common subsequence of", "\"gatac\" and \"acgtc\" is \"atc\" of length 3.", "\u2022 gatac", "\u2022 acgtc", "Example applications:", "Spelling discrepancies", "DNA similarity", "Trajectory analysis"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=12&isPrimary=false&absoluteTime=13351719660.539", "start_time": 2160, "end_time": 2340}, {"data": ["Let me show you if you care what more formally you could think about as being a sub sequence.", "But I hope that the idea was maybe more clear from the example previously.", "And let me just ask, are there questions about the problems set up?", "Well, what we'd like to do. Yes.", "You care about this too? Something good.", "So the question is, what about ties? So in general, there may be multiple strings which are sub sequences of both and are the same length.", "Right. That could certainly happen. And in general here, I just want the number for the beginning.", "So if they're all like three, then just three would be the answer.", "It is true that if you want the sequence itself, there could be multiple that are all optimal.", "Usually, unless I say something otherwise, then any of the optimal sub sequences would be acceptable.", "You can break ties arbitrarily and we'll actually see precisely where the tie breaking would show up when we look at an algorithm for this.", "That'll be true. Generally, by the way, when we talk about optimization problems in this class.", "Compute for me the thing that is maximum in some way or minimum in some way,", "that if there are multiple solutions that are tied for the optimal objective, that returning any of those optimal solutions will be acceptable.", "More Formally...", "\u2022 Given two strings of characters:", "\u2022 a = ao,al, , am\u2014I, b = bo, bl,", "\u2022 A subsequence of a is ail , atz, , aik where", "0 S il < iz < < itn\u2014l (similarly for b).", "\u2022 [i.e., obtained by deleting elements Without reordering)", "\u2022 Find the length of the longest string that is a", "subsequence of a and b."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=2355&isPrimary=true&absoluteTime=13351719855.539", "start_time": 2355, "end_time": 2445}, {"data": ["That's also a reasonable place to start for a problem is if I wasn't trying to optimize it or to make it more efficient,", "if I was just trying to compute search over all possibilities, what would that look like?", "Well, a subsequent is a strange kind of a thing. Okay.", "If I wanted to do something like search over all possible sub sequences, there actually an exponential number of them.", "Let's think about it for every character. I can either keep it in the sub sequence or not keep it in the sub sequence.", "Meaning for every character,", "I've got two choices and I'll get a different sub sequence for every choice I make on each of in characters to do the impossibilities.", "If you think back to your come to work stay, or if you don't want to think about coming to work, that's okay too.", "That'll be slow and it'll take you at least linear Time to check whether a given s is a sub sequence of the other 12.", "Okay. So the brute force solution here isn't just slow by, let's say, like a linear factor term or something like that is again, basically unworkable.", "The brute force solution basically might scale even to rather small strings in this case.", "So we'd like to come up with a more efficient solution.", "We puzzle around and we haven't been able to think of a greedy algorithm that seems to", "work in all cases or that we can prove anything for the brute force solution seems slow.", "One of the things I hope that you will begin to feel in your heart after a couple of weeks is that the not the wildest, not the most sophisticated,", "not the most intellectual, but that the cleanest way to write the correct algorithm for problems like this is dynamic programing.", "Because I think in very many cases it is the cleanest way to write a simple correct algorithm and then try to optimize it.", "So let's try to do that as our exponential time goes again.", "Brute Force Solution?", "A subsequence of a is a, a\u2022", "... , aik where", "0 Sil < i2 < < ik im-l (similarly for b).", "\u2022 [i.e., obtained by deleting elements without reordering]"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=14&isPrimary=false&absoluteTime=13351720020.539", "start_time": 2520, "end_time": 2637}, {"data": ["Suppose that the recursion fairy magically tells you that hey, the likes of GTA and GTI is two and the subsequent is 80 by the way.", "But someone just tells you that So think recursively. Someone just tells me this is the solution to the same problem.", "On a subset of the input I scratched out and faded the CS at the end.", "I'm not thinking about those now. The question is, if someone told you that, what?", "How should you answer the question with the longest common sub sequence of the whole strings?", "Usually that means thinking through cases. So suppose someone tells you the answer to a subset of the problem.", "Let's think through the cases of how we would answer the larger problem.", "Thinking with the Recursion Fairy", "(Abstraction)...", "Suppose you could magically get the LCS of a prefix", "of the strings...", "gatac", "acgtc"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=15&isPrimary=false&absoluteTime=13351720200.539", "start_time": 2700, "end_time": 2748}, {"data": ["What observation can we draw their? When I'm trying to think recursively about dynamic programing,", "I usually like to say the simplest things that I can that are true and the simplest thing I can say that is true if the last characters differ,", "is that the longest common sub sequence cannot end with both of them.", "It could end with one of them, it could end with the other of them, but it can't end with both of them.", "If that's the case,", "then the overall longest common sub sequence since it can't end with both A and end with T could only one or the other potentially the overall longest", "common subsequent either is going to be the longest common sub sequence of the prefix g80 not not including the end of the whole string t right.", "That would be the case if the longest comes come in subsequent does not end with that egg at the beginning,", "then these two things would be equal because I've only eliminated something that wasn't in the longest common such sequence.", "Or of course it could be the likes of the extreme GTA and the prefix ac g, not including the T.", "Right. Because I said the longest common sense sequence either doesn't end with that first day or it doesn't", "end with actually with the A in the first string or it doesn't end with a T in the second string.", "These are exactly those two cases and.", "I'm going to get the answer to both of these with recursive calls on subsets of the input less than the original string.", "What am I going to do with the results?", "I can't increment it because I haven't necessarily found a new matching character, but I want the longest comments of sequence.", "So I should just take the larger whichever of these two happens to be larger in the context of recursive call.", "It means I'm gonna make one recursive call,", "not including the A in the first string and another recursive call, not including the T in the second string.", "I'm going to get two results and I'll take the better of them very frequently in the case analysis with dynamic programing.", "You will find yourself when developing recursion saying, Well, either I would take this or I would take that.", "Let me try both recursive calls and take the better result.", "That would be a very common thing that you'll do, and that's one of the reasons why dynamic programing is so great in the sense of being clean,", "is that the correctness of that can sometimes almost be straightforward and obvious because it feels as if,", "well, I'm simply considering all of the possibilities.", "Either I match on the last characters or I don't use the last character of one string, or I don't use the last character of another string.", "I take the best of any results from all of those three possibilities.", "Okay. If he died again, what that would look like if we were then to write up a recursive algorithm and just run it.", "Building Recursive Intuition", "\u2022 gata", "\u2022 acgt", "with Cases", "Case 2: If the last characters differ, then", "the LCS cannot end with both..."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=16&isPrimary=false&absoluteTime=13351720380.539", "start_time": 2880, "end_time": 3054}, {"data": ["Remembering that whenever we have a branch where we made the two recursive calls in the second case will simply take the better result.", "It would be like we start actually, we start here.", "We can match all these last two characters, so we'll do that. We need to get the longest common sub sequence of what would remain.", "That's a recursive call here. The last two characters are not equal, so we're going to write two possibilities.", "One where we omit the A and another where we omit the T, and we'll take the better of the two results that we get in the end.", "We continue in this fashion. So, for example, the A and the G on the left branch are not matching.", "So again, we try both possibilities, not including the error and not putting the g take the better of those results on the right branch.", "We do have a match. We'll go ahead and include that and we'll ask what's the best solution with the remainder of the strings?", "Now, the problem, of course, is that we could potentially have a slow runtime here.", "But fortunately, we know a little something about dynamic programing.", "We have techniques to deal with slowness resulting from repeated sub calls.", "Those techniques for dealing with slowness from repeated circles are in some ways almost mechanical.", "I can actually tell you here's the process and we'll go through it several times and you'll go through it yourself as well.", "Developing the recurrence is the most problem specific thing of all and may take some time.", "Some intuition, some examples requires you to think recursively.", "If the recurring very told me the answer to a subset of the problems is a problem, how would I answer the larger problem?", "And then typically the thinking cases. Let's focus on that for a moment.", "Diagramming Recursion", "Recall we want the longest", "common subsequence.", "Whenever there is a branch: Take", "the result with the better", "(longer) result."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=17&isPrimary=false&absoluteTime=13351720560.539", "start_time": 3060, "end_time": 3171}, {"data": ["Note there are quadratic only mini sub problems of this form.", "One for each possible ie up to the length of the first string and for each possible j after the length of the second string.", "So whereas the sort of straightforward recursive algorithm I was just thinking about and the recursion tree may have been slow and it would be slow.", "There are actually only quadratic mini sub problems. That almost certainly means the slowness would have been because of repeated support.", "We can write a recurrence to characterize what it is that we want to compute.", "This looks like some weird mathematical garbage group that I'm pasting, but it is precisely what we've been talking about.", "We're thinking recursively with cases the longest common subsequent using the characters", "up to a high from the first string and up to be j from the second string is zero.", "If there are no characters in one of those, that's our base case.", "And if one of them is empty, then just zero. Otherwise, we had two cases that we considered.", "The first case was the good case. When I equals BGA, that is to say we're the last characters of the prefix as we're currently considering were equal.", "We could match on those. In that case, we had concluded we should certainly count that character.", "It would be included in the longest common sub sequence. That's why we have one.", "Plus the one is counting that character in the longest common sub sequence.", "Then we have a recursive call to say, okay, hey,", "what would the the longest common subsequent be of the previous prefixes of the strings, not including the characters and B.J.", "The third case was that the third case here was the second one.", "We considered the base case where the last two characters are not equal.", "We can't match on them. The longest common sub sequence could only possibly end with one of them.", "We simply tried both possibilities, not including the last character of a That's a recursive call.", "We're not including the last character of B. That's another recursive call. We take the better of those two results we want longest.", "So better means maximum here. Okay.", "The recurrence is really what you're aiming at in the first part of clearly specified recurrence that you feel like you understand what's going on.", "It's really what you're aiming at when you're first developing a dynamic programing algorithm to see if that's making sense to us.", "Define Subproblems, Develop a", "Recurrence", "Let lcs(i,j) be the length of the longest common", "subsequence between ao, al ... ai and bo, bl bj."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=18&isPrimary=false&absoluteTime=13351720740.539", "start_time": 3240, "end_time": 3396}, {"data": ["Yes, I think it was an issue, I think, on the subject.", "So you. No, it's too much.", "This is how much of this world is coming.", "It's end.", "Well, I think it should be positive for posterity.", "We all care about what's going on with us.", "The number 16000.", "This is for. It's for improving.", "Think. I feel like this is going to mean something to me.", "Say this like I know what I mean.", "Yeah. You know what I'm saying?", "It's just kind of like a be able to use the word luxury is just a little.", "That's all the green light to go through the screen.", "As you can see, obviously going, I feel like this is I going to tell you that this is not something I just announced.", "In-Class Exercise", "duke.is/2/eyhu", "Talk with your neighbors,", "Submit on your own.", "Graded for completion,", "not correctness."], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=19&isPrimary=false&absoluteTime=13351720920.539", "start_time": 3420, "end_time": 3600}, {"data": ["the E and with one of these E's and the two LS matched with these two else.", "But the longest common substring is just 3ell which you could match with e.", "L l here. The difference is that sub strings can have those breaks.", "I cannot allow those deletions and saying there is I'm going to parameterized our problem.", "Also using the longest common suffix, the suffix is just a a substring that's a suffix of the string comes at the end.", "Right. The opposite of a prefix.", "The first question asks, You suppose that the last two characters looking at the first of two I in the end up to J and A B are equal.", "Then the longest common suffix should equal What?", "Thinking about the recursion or the recurrence? Most of you are correct.", "It should be the longest common suffix using all but the last characters plus one.", "If the last two characters are equal and you're getting a suffix,", "certainly it could include those last characters as well as the longest common suffix of whatever comes prior.", "So similar to what we saw with sub sequence. Well done there.", "The third one supposes, however, that those last two characters are not equal.", "Then what should the longest common suffix up to and up to B.J. be?", "The correct answer here is zero.", "This was intentionally placed to make it look like you should say the same thing as the longest time and subsequent.", "That's not correct. Right. A suffix has to be a substring up to and including the last characters.", "If the last two characters are not equal, then no suffix between those two strings is common.", "No, not empty one because it won't match the last characters to the match.", "Note. Let me point out here, and you may have been thinking in your head about the longest common substring, and that would be correct.", "This is why it's so important to be careful about what your parameterization is.", "What are your sub problems? The longest common suffix in this case is indeed zero.", "That does not mean that the longest common substring for these two strings is necessarily zero.", "Right. And let's go to that question. The longest common substring, etc., etc.", "If the longest common substring is also a suffix, then it is clear that the longest common substring equals the longest common suffix.", "That's not a super interesting thing to say. If, however, the longest common substring is not a suffix, then what is it equal to?", "Questi ons", "LDS trpaass (2/6/2024)", "Responses", "I. Here is the longest Common substring (LCSubstring) problem: Given two strings A and B,", "return the length of the longest string S that is a substring of both A and B.", "For example. whereas the longest common subsequence Of A:-gatac\" and was", "\"gtc- of length 3. this is not a substring of A, The longest common substring is \u2022ac\" which", "has length 2.", "SeiRt", "2. Let LCSuffix(i, j) be the length of the longest common suffix of and"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=21&isPrimary=false&absoluteTime=13351721280.539", "start_time": 3780, "end_time": 3960}, {"data": ["you get a recurrence relation, something like this. That'll be exponential time.", "You've got at least two recursive calls. You're only making arithmetic progress toward the base case.", "That's our scary, exponential goals. But there were only quadratic sub problems in total.", "So if we only solved each sub problem once, x will be in polynomial time, massively more scalable.", "That is what we would like. We'll do that with our usual ones.", "Straightforward Recursion would", "be Inefficient", "o,", "0, j 2 = b[jl", "v,j), i20,j20,", "To compute LCS(m,n) in the worst case", "\u2014 l,n) + +0(1)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=4047&isPrimary=true&absoluteTime=13351721547.539", "start_time": 4047, "end_time": 4077}, {"data": ["Why is that helpful? We're going to develop a bottom up iterative approach and we will store the answers", "Identifying Subproblem", "Dependency", "For a given subproblem, on what other subproblems", "does it depend? Read from the recurrence.", "o,", "1+ LCS(i- l,j\u2014 1),", "i < 0 or j < 0", "i > O, j Oaf!) = bbl", "max (LCS(i\u2014 l,j), LCS(i,j \u2014 1)) i 2 0, j 20, bbl", "LCS(i - l,j\u2014 1)", "LCS(i\u2014 1, j)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=23&isPrimary=false&absoluteTime=13351721640.539", "start_time": 4140, "end_time": 4146}, {"data": ["your armed with an understanding of an order in which you want to iterate over your sub problems.", "You're ready to write an iterative, dynamic programing algorithm.", "If you have gotten to this stage, then rather than writing a table and then doing strange things and memorizing arbitrary facts from the internet,", "the process of writing the algorithm is almost mechanical.", "I create a table to store the answer to my sub problems. Online four and five.", "I iterate over the sub problems which are parameterized by IMJ in the order I previously determined would be that for a given iterate of I and J,", "I want to compute the answer of lc us. I j. I will do that by cases repeating almost verbatim what is written in my recurrence", "Solve the Subproblems Iteratively", "from the Base Case", "0,", "LCS(iO)\u2014 i + i).", "01234", "2", "3", "4"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=4266&isPrimary=true&absoluteTime=13351721766.539", "start_time": 4266, "end_time": 4320}, {"data": ["You'll see this in many dynamic programing algorithms. One is to expand the base case and check explicitly for that condition.", "So for example, you could say let me actually explicitly check for the case where IAG is equal to zero and deal with", "that separately so that I never have to try to like call a negative index position in the table.", "That would be one way to fix it, a different way to fix it, which you'll see fairly commonly,", "is to pad use a slightly larger table and pad the first row and column of the table with the base case values.", "I'll do that here in my solution. So rather than an m by end table, I'll actually make an N plus one by end plus one table,", "and then I'll pad the first row in the first column with zeros corresponding to our base case.", "So a couple of ways to fix that kind of things that you'll see in a lot of approaches as you're trying to do this iteratively.", "Fixes for Base Cases", "Option I: Expand base case and check explicitly for", "base case condition", "6:", "7:", "If i 0 or j 0 then", "T 1 if atil bbl or 0 otherwise"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=0eb7ba8e-bcc0-453f-876a-b10e0146f5fe&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=4368&isPrimary=true&absoluteTime=13351721868.539", "start_time": 4368, "end_time": 4422}, {"data": ["That is so strong the on. My sister and I are brought here with a British accent already.", "I know, and I don't know why.", "Just because. I got to tell you something that I can say right now.", "I'm general go up like the next day. So if it hasn't already, it's just saying, Oh, yeah, yeah, yeah, I've got a.", "So I wasn't bad about it, but I have something going like that.", "And it has been faster than the expected decision after they said that like ending a race operation, like with the rest of around sometimes.", "Oh, I see. Exactly.", "It's never easy. Never be able to tell you how to do this.", "You can always try to sort through this hard.", "And I think the littlest can always be able to on some time.", "They just can't be like the next guy. Yeah, those are the two.", "It's a set of possibilities. So then in an algorithm,", "would you say that like what did you assume or was there any queries about school hypersonic weapons if they're raids like well I really time Yeah.", "So but I mean to you shall we say that whether it's the best time, if it's relevant to the problem.", "I mean there will be cases where it won't matter to us.", "It's like I'm going to smoosh these two things together and then I'm going to loop over them anyway.", "And in that case, it doesn't matter, because you know what I mean?", "So I can I can show these problems specific. But yeah, but in terms of like what you're working with.", "Yeah I can working with the raised and it'll take, you know, your time to combine them but you can make sense of the time.", "Yeah. The link less you can combine them in constant time but indexing might not.", "Okay. So it's like you want to try. Is it really.", "You know, it's about the parallel. Yeah, I know.", "It's just hunger and things like, but not really programing.", "Tracing the Algorithm", "Going to \"fill in a table\" and draw back", "arrows to the maximizing previous", "subproblem (breaking ties arbitrarily)", "o", "2", "o", "o", "4", "o", "o", "o", "o", "4:", "6:", "8:", "for k = O to n \u2014 I do", "for i 1 to m do", "for j = 1 to n do", "if a[i] = b[jl then", "1", "2", "3", "4", "5", "g", "a", "c", "o", "o", "9: T(illjl = 1", "else", "max(T(i", "return", "Runtime is O(nm)", "11", "\u2014 Il(jl,", "\u2014 Il)"], "image": "https://duke.hosted.panopto.com/Panopto/Pages/Viewer/Thumb.aspx?eventTargetPID=13ee9285-4f1d-45f6-9afa-b10e0146cf77&sessionPID=12c0968a-2038-46ee-b174-b0ce0147522d&number=25&isPrimary=false&absoluteTime=13351722000.539", "start_time": 4500, "end_time": 4680}]}